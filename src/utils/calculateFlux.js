import * as THREE from 'three'
import { sampleGaussianSurface } from '../Surfaces/gaussianSurfaceSampler'
import { K_E, EPSILON_0, EPSILON_0_REAL } from '../physics/constants'
import CuboidShape from '../Surfaces/cuboidShape'
import { efields } from '../physics'
import { toVector3, getSurfaceShape } from '../Surfaces/gaussianSurfaceGeometry'
import {
  estimatePlaneEnclosedCharge,
  estimateWireEnclosedCharge,
  objectIntersectsSurface,
} from '../Surfaces/gaussianSurfaceIntersections'

// Calculates the total electric field generated by all objects at a target point.
function computeFieldAtPoint(objects, targetPos) {
  const multiplier = K_E
  const target = targetPos instanceof THREE.Vector3
    ? targetPos
    : new THREE.Vector3(...(Array.isArray(targetPos) ? targetPos : [0, 0, 0]))
  const field = new THREE.Vector3()

  for (const obj of objects) {
    if (!obj) continue
    const sourcePosition = new THREE.Vector3(...(obj.position ?? [0, 0, 0]))
    const charge = Number(obj.charge ?? 0)
    const chargeDensity = Number(obj.charge_density ?? 0)

    if (obj.type === 'charge' || obj.type === 'testPointCharge') {
      const rVec = new THREE.Vector3().subVectors(target, sourcePosition)
      const rSq = rVec.lengthSq()
      if (rSq < 1e-6) continue
      const fieldMagnitude = multiplier * charge / rSq
      field.addScaledVector(rVec.normalize(), fieldMagnitude)
    } else if (obj.infinite && (obj.type === 'plane' || obj.type === 'wire')) {
      if (obj.type === 'wire') {
        const contrib = efields.infiniteWireEField(sourcePosition, chargeDensity, target, obj.direction)
        field.add(contrib)
      } else if (obj.type === 'plane') {
        const contrib = efields.infinitePlaneEField(sourcePosition, chargeDensity, target, obj.direction)
        field.add(contrib)
      }
    } else if (obj.type === 'plane') {
      const contrib = efields.finitePlaneEField(sourcePosition, obj.direction, obj.dimensions, chargeDensity, target)
      field.add(contrib)
    } else if (obj.type === 'wire') {
      const contrib = efields.finiteWireEField(sourcePosition, obj.direction, obj.height, obj.radius, chargeDensity, target)
      field.add(contrib)
    } else if (obj.type === 'chargedSphere') {
      const contrib = efields.chargedSphereEField(sourcePosition, obj.radius, chargeDensity, obj.isHollow, target)
      field.add(contrib)
    } else if (obj.type === 'concentricSpheres') {
      const contrib = efields.concentricSpheresField(sourcePosition, obj.radiuses, obj.materials, obj.dielectrics, obj.charges, target)
      field.add(contrib)
    } else if (obj.type === 'concentricInfWires') {
      const contrib = efields.concentricInfiniteWiresField(sourcePosition, obj.direction, obj.radiuses, obj.materials, obj.dielectrics, obj.charges, target)
      field.add(contrib)
    } else if (obj.type === 'stackedPlanes') {
      const numPlanes = Array.isArray(obj.charge_densities) ? obj.charge_densities.length : 0
      if (numPlanes === 0) continue
      const spacing = obj.spacing || 1
      const directionVec = new THREE.Vector3(...(obj.direction ?? [0, 1, 0])).normalize()
      const centerOffset = (numPlanes - 1) * spacing / 2
      for (let i = 0; i < numPlanes; i++) {
        const planePos = sourcePosition.clone().add(directionVec.clone().multiplyScalar((i * spacing) - centerOffset))
        const density = Number(obj.charge_densities[i] ?? 0)
        const contrib = obj.infinite
          ? efields.infinitePlaneEField(planePos, density, target, obj.direction)
          : efields.finitePlaneEField(planePos, obj.direction, obj.dimensions, density, target)
        field.add(contrib)
      }
    } else if (Array.isArray(obj.charges) && obj.charges.length > 0) {
      // For paths/coils, charges array contains positions [x,y,z] and charge magnitude is in obj.charge
      // For other objects (wire, plane), charges array contains {position: [x,y,z], charge: number}
      const isPathOrCoil = obj.type === 'path' || obj.type === 'coil'
      
      for (const embedded of obj.charges) {
        let embeddedPos, chargeValue
        
        if (isPathOrCoil) {
          // Path/coil: embedded is just [x, y, z] position array
          embeddedPos = sourcePosition.clone().add(new THREE.Vector3(
            embedded[0] ?? 0,
            embedded[1] ?? 0,
            embedded[2] ?? 0
          ))
          chargeValue = Number(obj.charge ?? 0)
        } else {
          // Wire/plane: embedded is {position: [x,y,z], charge: number}
          embeddedPos = sourcePosition.clone().add(new THREE.Vector3(
            embedded.position?.[0] ?? 0,
            embedded.position?.[1] ?? 0,
            embedded.position?.[2] ?? 0
          ))
          chargeValue = Number(embedded.charge ?? 0)
        }
        
        const rVec = new THREE.Vector3().subVectors(target, embeddedPos)
        const rSq = rVec.lengthSq()
        if (rSq < 1e-6) continue
        const fieldMagnitude = multiplier * chargeValue / rSq
        field.addScaledVector(rVec.normalize(), fieldMagnitude)
      }
    }
  }

  return field
}

// Tries to evaluate the net charge enclosed by a Gaussian surface using only discrete charges.
function computeEnclosedDiscreteCharge(surface, objects) {
  const shape = getSurfaceShape(surface)
  if (!shape || typeof shape.containsPoint !== 'function') {
    return { canUseGauss: false, enclosedCharge: 0 }
  }

  const position = toVector3(surface.position || [0, 0, 0])
  const q = CuboidShape.buildQuaternion(surface)
  const inv = q.clone().invert()

  const toLocal = (worldPoint) => worldPoint.clone().sub(position).applyQuaternion(inv)

  let enclosedCharge = 0
  let evaluatedAny = false
  let canUseGauss = true

  const processCharge = (worldPos, chargeValue) => {
    evaluatedAny = true
    if (!Number.isFinite(chargeValue)) return
    const local = toLocal(worldPos)
    if (shape.containsPoint(local)) enclosedCharge += chargeValue
  }

  for (const obj of objects) {
    if (!obj || obj.id === surface.id) continue
    if (obj.type === 'surface') continue

    if (obj.type === 'charge' || obj.type === 'testPointCharge') {
      const worldPos = toVector3(obj.position || [0, 0, 0])
      const chargeValue = Number(obj.charge ?? 0)
      processCharge(worldPos, chargeValue)
      continue
    }

    if (Array.isArray(obj.charges) && obj.charges.length > 0) {
      const basePos = toVector3(obj.position || [0, 0, 0])
      
      // For paths/coils, charges array contains positions [x,y,z] and charge magnitude is in obj.charge
      // For other objects (wire, plane), charges array contains {position: [x,y,z], charge: number}
      const isPathOrCoil = obj.type === 'path' || obj.type === 'coil'
      
      for (const embedded of obj.charges) {
        let offset, chargeValue
        
        if (isPathOrCoil) {
          // Path/coil: embedded is just [x, y, z] position array
          offset = new THREE.Vector3(
            embedded[0] ?? 0,
            embedded[1] ?? 0,
            embedded[2] ?? 0
          )
          chargeValue = Number(obj.charge ?? 0)
        } else {
          // Wire/plane: embedded is {position: [x,y,z], charge: number}
          offset = new THREE.Vector3(
            embedded.position?.[0] ?? 0,
            embedded.position?.[1] ?? 0,
            embedded.position?.[2] ?? 0
          )
          chargeValue = Number(embedded.charge ?? 0)
        }
        
        const worldPos = basePos.clone().add(offset)
        processCharge(worldPos, chargeValue)
      }
      continue
    }

    if (obj.type === 'plane') {
      const estimate = estimatePlaneEnclosedCharge(surface, obj)
      if (estimate.canEstimate) {
        evaluatedAny = true
        enclosedCharge += estimate.enclosedCharge
        continue
      }
      canUseGauss = false
      break
    }

    if (obj.type === 'wire') {
      const estimate = estimateWireEnclosedCharge(surface, obj)
      if (estimate.canEstimate) {
        evaluatedAny = true
        enclosedCharge += estimate.enclosedCharge
        continue
      }
      canUseGauss = false
      break
    }

    canUseGauss = false
    break
  }

  return { canUseGauss: canUseGauss && evaluatedAny, enclosedCharge }
}

// Computes electric flux for every Gaussian surface in the scene.
export default function calculateFlux(sceneObjects = []) {
  const surfaces = sceneObjects.filter(obj => obj?.type === 'surface')
  const results = []

  for (const surface of surfaces) {
    const { canUseGauss, enclosedCharge } = computeEnclosedDiscreteCharge(surface, sceneObjects)
    if (canUseGauss) {
      const flux = enclosedCharge / EPSILON_0_REAL
      results.push({ id: surface.id, name: surface.name, flux })
      continue
    }

    const intersects = sceneObjects.some(obj => obj && obj.id !== surface.id && objectIntersectsSurface(surface, obj))
    if (!intersects) {
      results.push({ id: surface.id, name: surface.name, flux: 0 })
      continue
    }

    const effectiveSampleCount = Math.max(surface.sampleCount || 64, 2048*128)
    const samples = sampleGaussianSurface({ ...surface, sampleCount: effectiveSampleCount }, { includeNormals: true })
    if (!samples.length) {
      results.push({ id: surface.id, name: surface.name, flux: 0 })
      continue
    }

    let fluxSum = 0
    for (const sample of samples) {
      const field = computeFieldAtPoint(sceneObjects, sample.position)
      if (!sample.normal || typeof sample.area !== 'number') continue
      fluxSum += field.dot(sample.normal) * sample.area
    }

    const scaledFlux = fluxSum * (EPSILON_0 / EPSILON_0_REAL)
    results.push({ id: surface.id, name: surface.name, flux: scaledFlux })
  }

  return results
}
