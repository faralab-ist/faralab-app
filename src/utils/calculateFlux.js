import * as THREE from 'three'
import { sampleGaussianSurface } from '../Surfaces/gaussianSurfaceSampler'
import { K_E, EPSILON_0, EPSILON_0_REAL } from '../physics/constants'
import CuboidShape from '../Surfaces/cuboidShape'
import { efields } from '../physics'
import { toVector3, getSurfaceShape } from '../Surfaces/gaussianSurfaceGeometry'
import {
  estimatePlaneEnclosedCharge,
  estimateWireEnclosedCharge,
  objectIntersectsSurface,
} from '../Surfaces/gaussianSurfaceIntersections'

// Calculates the total electric field generated by all objects at a target point.
function computeFieldAtPoint(objects, targetPos) {
  const multiplier = K_E
  const target = targetPos instanceof THREE.Vector3
    ? targetPos
    : new THREE.Vector3(...(Array.isArray(targetPos) ? targetPos : [0, 0, 0]))
  const field = new THREE.Vector3()

  for (const obj of objects) {
    if (!obj) continue
    const sourcePosition = new THREE.Vector3(...(obj.position ?? [0, 0, 0]))
    const sourceArray = sourcePosition.toArray()
    const targetArray = target.toArray()
    const charge = Number(obj.charge ?? 0)
    const chargeDensity = Number(obj.charge_density ?? 0)

    if (obj.type === 'charge' || obj.type === 'testPointCharge') {
      const rVec = new THREE.Vector3().subVectors(target, sourcePosition)
      const rSq = rVec.lengthSq()
      if (rSq < 1e-6) continue
      const fieldMagnitude = multiplier * charge / rSq
      field.addScaledVector(rVec.normalize(), fieldMagnitude)
    } else if (obj.infinite && (obj.type === 'plane' || obj.type === 'wire')) {
      if (obj.type === 'wire') {
        const contrib = efields.infiniteWireEField(sourceArray, chargeDensity, targetArray, obj.direction)
        field.add(contrib)
      } else if (obj.type === 'plane') {
        const contrib = efields.infinitePlaneEField(sourceArray, chargeDensity, targetArray, obj.direction)
        field.add(contrib)
      }
    } else if (obj.type === 'plane') {
      const contrib = efields.finitePlaneEField(sourceArray, obj.direction, obj.dimensions, chargeDensity, targetArray)
      field.add(contrib)
    } else if (obj.type === 'wire') {
      const contrib = efields.finiteWireEField(sourceArray, obj.direction, obj.height, obj.radius, chargeDensity, targetArray)
      field.add(contrib)
    } else if (obj.type === 'chargedSphere') {
      const contrib = efields.chargedSphereEField(sourceArray, obj.radius, chargeDensity, obj.isHollow, targetArray)
      field.add(contrib)
    } else if (obj.type === 'concentricSpheres') {
      if (!Array.isArray(obj.radiuses) || obj.radiuses.length === 0) continue
      if (!Array.isArray(obj.charges) || obj.charges.length === 0) continue
      const contrib = efields.concentricSpheresEField(sourceArray, obj.radiuses, obj.materials, obj.dielectrics, obj.charges, targetArray)
      field.add(contrib)
    } else if (obj.type === 'concentricInfWires') {
      if (!Array.isArray(obj.radiuses) || obj.radiuses.length === 0) continue
      if (!Array.isArray(obj.charges) || obj.charges.length === 0) continue
      const contrib = efields.concentricInfiniteWiresEField(sourceArray, obj.direction, obj.radiuses, obj.materials, obj.dielectrics, obj.charges, targetArray)
      field.add(contrib)
    } else if (obj.type === 'stackedPlanes') {
      const numPlanes = Array.isArray(obj.charge_densities) ? obj.charge_densities.length : 0
      if (numPlanes === 0) continue
      const spacing = obj.spacing || 1
      const directionVec = new THREE.Vector3(...(obj.direction ?? [0, 1, 0])).normalize()
      const centerOffset = (numPlanes - 1) * spacing / 2
      for (let i = 0; i < numPlanes; i++) {
        const planePos = sourcePosition.clone().add(directionVec.clone().multiplyScalar((i * spacing) - centerOffset))
        const density = Number(obj.charge_densities[i] ?? 0)
        const contrib = obj.infinite
          ? efields.infinitePlaneEField(planePos, density, target, obj.direction)
          : efields.finitePlaneEField(planePos, obj.direction, obj.dimensions, density, target)
        field.add(contrib)
      }
    } else if (Array.isArray(obj.charges) && obj.charges.length > 0) {
      // For paths/coils, charges array contains positions [x,y,z] and charge magnitude is in obj.charge
      // For other objects (wire, plane), charges array contains {position: [x,y,z], charge: number}
      const isPathOrCoil = obj.type === 'path' || obj.type === 'coil'
      
      for (const embedded of obj.charges) {
        let embeddedPos, chargeValue
        
        if (isPathOrCoil) {
          // Path/coil: embedded is just [x, y, z] position array
          embeddedPos = sourcePosition.clone().add(new THREE.Vector3(
            embedded[0] ?? 0,
            embedded[1] ?? 0,
            embedded[2] ?? 0
          ))
          chargeValue = Number(obj.charge ?? 0)
        } else {
          // Wire/plane: embedded is {position: [x,y,z], charge: number}
          embeddedPos = sourcePosition.clone().add(new THREE.Vector3(
            embedded.position?.[0] ?? 0,
            embedded.position?.[1] ?? 0,
            embedded.position?.[2] ?? 0
          ))
          chargeValue = Number(embedded.charge ?? 0)
        }
        
        const rVec = new THREE.Vector3().subVectors(target, embeddedPos)
        const rSq = rVec.lengthSq()
        if (rSq < 1e-6) continue
        const fieldMagnitude = multiplier * chargeValue / rSq
        field.addScaledVector(rVec.normalize(), fieldMagnitude)
      }
    }
  }

  return field
}

// Tries to evaluate the net charge enclosed by a Gaussian surface using only discrete charges.
function computeEnclosedDiscreteCharge(surface, objects) {
  const shape = getSurfaceShape(surface)
  if (!shape || typeof shape.containsPoint !== 'function') {
    return { canUseGauss: false, enclosedCharge: 0, fluxOverride: null }
  }

  const position = toVector3(surface.position || [0, 0, 0])
  const q = CuboidShape.buildQuaternion(surface)
  const inv = q.clone().invert()

  const toLocal = (worldPoint) => worldPoint.clone().sub(position).applyQuaternion(inv)

  let enclosedCharge = 0
  let evaluatedAny = false
  let canUseGauss = true
  let fluxOverride = null

  const processCharge = (worldPos, chargeValue) => {
    evaluatedAny = true
    if (!Number.isFinite(chargeValue)) return
    const local = toLocal(worldPos)
    if (shape.containsPoint(local)) enclosedCharge += chargeValue
  }

  for (const obj of objects) {
    if (!obj || obj.id === surface.id) continue
    if (obj.type === 'surface') continue
    if (fluxOverride !== null && obj.type !== 'concentricSpheres') {
      canUseGauss = false
      break
    }

    if (obj.type === 'charge' || obj.type === 'testPointCharge') {
      const worldPos = toVector3(obj.position || [0, 0, 0])
      const chargeValue = Number(obj.charge ?? 0)
      processCharge(worldPos, chargeValue)
      continue
    }

    if (
      Array.isArray(obj.charges) &&
      obj.charges.length > 0 &&
      obj.type !== 'concentricSpheres' &&
      obj.type !== 'concentricInfWires'
    ) {
      const basePos = toVector3(obj.position || [0, 0, 0])
      
      // For paths/coils, charges array contains positions [x,y,z] and charge magnitude is in obj.charge
      // For other objects (wire, plane), charges array contains {position: [x,y,z], charge: number}
      const isPathOrCoil = obj.type === 'path' || obj.type === 'coil'
      
      for (const embedded of obj.charges) {
        let offset, chargeValue
        
        if (isPathOrCoil) {
          // Path/coil: embedded is just [x, y, z] position array
          offset = new THREE.Vector3(
            embedded[0] ?? 0,
            embedded[1] ?? 0,
            embedded[2] ?? 0
          )
          chargeValue = Number(obj.charge ?? 0)
        } else {
          // Wire/plane: embedded is {position: [x,y,z], charge: number}
          offset = new THREE.Vector3(
            embedded.position?.[0] ?? 0,
            embedded.position?.[1] ?? 0,
            embedded.position?.[2] ?? 0
          )
          chargeValue = Number(embedded.charge ?? 0)
        }
        
        const worldPos = basePos.clone().add(offset)
        processCharge(worldPos, chargeValue)
      }
      continue
    }

    if (obj.type === 'plane') {
      const estimate = estimatePlaneEnclosedCharge(surface, obj)
      if (estimate.canEstimate) {
        evaluatedAny = true
        enclosedCharge += estimate.enclosedCharge
        continue
      }
      canUseGauss = false
      break
    }

    if (obj.type === 'wire') {
      const estimate = estimateWireEnclosedCharge(surface, obj)
      if (estimate.canEstimate) {
        evaluatedAny = true
        enclosedCharge += estimate.enclosedCharge
        continue
      }
      canUseGauss = false
      break
    }

    if (obj.type === 'concentricSpheres') {
      if (fluxOverride !== null) {
        canUseGauss = false
        break
      }
      if (surface.surfaceType !== 'sphere') {
        canUseGauss = false
        break
      }

      const surfaceCenter = toVector3(surface.position || [0, 0, 0])
      const sphereCenter = toVector3(obj.position || [0, 0, 0])
      if (surfaceCenter.distanceTo(sphereCenter) > 1e-3) {
        canUseGauss = false
        break
      }

      const radiuses = Array.isArray(obj.radiuses) ? obj.radiuses : []
      if (!radiuses.length) {
        evaluatedAny = true
        continue
      }

      const charges = Array.isArray(obj.charges) ? obj.charges : []
      const materials = Array.isArray(obj.materials) ? obj.materials : []
      const dielectrics = Array.isArray(obj.dielectrics) ? obj.dielectrics : []
      const normalizedCharges = radiuses.map((_, i) => Number(charges[i] ?? 0))
      const normalizedMaterials = radiuses.map((_, i) => materials[i] ?? 'conductor')
      const useDirectCharges = materials.length < radiuses.length
      const chargesPerSurface = useDirectCharges
        ? normalizedCharges
        : efields.chargePerSphereSurface(radiuses, normalizedCharges, normalizedMaterials)

      const surfaceRadius = Math.abs(surface.radius ?? 0)
      const epsilon = 1e-6
      let layer = -1
      for (let i = 0; i < radiuses.length; i++) {
        const r = radiuses[i]
        if (Math.abs(surfaceRadius - r) <= epsilon) {
          if (i === radiuses.length - 1) {
            layer = -1
          } else {
            layer = i + 1
          }
          break
        }
        if (surfaceRadius < r - epsilon) {
          layer = i
          break
        }
      }

      if (layer === -1) {
        const totalCharge = normalizedCharges.reduce((sum, val) => sum + val, 0)
        fluxOverride = totalCharge / EPSILON_0_REAL
      } else {
        let enclosed = 0
        for (let i = 1; i <= layer; i++) {
          enclosed += chargesPerSurface[i - 1] ?? 0
        }
        const dielectricConst = Number(dielectrics[layer] ?? 1)
        if (Number.isFinite(dielectricConst) && Math.abs(dielectricConst) > 1e-9) {
          fluxOverride = enclosed / (EPSILON_0_REAL * dielectricConst)
        } else {
          fluxOverride = 0
        }
      }

      evaluatedAny = true
      continue
    }

    canUseGauss = false
    break
  }

  return { canUseGauss: canUseGauss && evaluatedAny, enclosedCharge, fluxOverride }
}

// Computes electric flux for every Gaussian surface in the scene.
export default function calculateFlux(sceneObjects = []) {
  const surfaces = sceneObjects
    .filter(obj => obj && (obj.type === 'surface' || ['sphere', 'cylinder', 'cuboid'].includes(obj.type)))
    .map(obj => (
      obj.type === 'surface'
        ? obj
        : { ...obj, type: 'surface', surfaceType: obj.surfaceType ?? obj.type }
    ))
  const results = []

  for (const surface of surfaces) {
    const { canUseGauss, enclosedCharge, fluxOverride } = computeEnclosedDiscreteCharge(surface, sceneObjects)
    if (canUseGauss) {
      const flux = Number.isFinite(fluxOverride) ? fluxOverride : (enclosedCharge / EPSILON_0_REAL)
      results.push({ id: surface.id, name: surface.name, flux })
      continue
    }

    const intersects = sceneObjects.some(obj => obj && obj.id !== surface.id && objectIntersectsSurface(surface, obj))
    if (!intersects) {
      results.push({ id: surface.id, name: surface.name, flux: 0 })
      continue
    }

    const effectiveSampleCount = Math.max(surface.sampleCount || 64, 2048*64)
    const samples = sampleGaussianSurface({ ...surface, sampleCount: effectiveSampleCount }, { includeNormals: true })
    if (!samples.length) {
      results.push({ id: surface.id, name: surface.name, flux: 0 })
      continue
    }

    let fluxSum = 0
    for (const sample of samples) {
      const field = computeFieldAtPoint(sceneObjects, sample.position)
      if (!sample.normal || typeof sample.area !== 'number') continue
      fluxSum += field.dot(sample.normal) * sample.area
    }

    const scaledFlux = fluxSum * (EPSILON_0 / EPSILON_0_REAL)
    results.push({ id: surface.id, name: surface.name, flux: scaledFlux })
  }

  return results
}
